

## 汉诺塔问题


## 运算符重载

在 C++ 中，运算符重载允许你定义或修改运算符（如 `+`, `-`, `*`, `<<`, `>>` 等）对用户自定义类型（如类和结构体）的行为。这使得自定义类型可以像内置类型一样使用运算符，增强了代码的可读性和可维护性。

运算符重载的语法类似于函数定义。以下是运算符重载的一些常见示例和使用方法：

### 示例：重载加法运算符 (`+`)

假设我们有一个表示二维点的类 `Point`，我们希望能够使用 `+` 运算符来相加两个点：

``` cpp
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 重载加法运算符
    Point operator+(const Point &p) const {
        return Point(x + p.x, y + p.y);
    }

    void display() const {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p1(1, 2), p2(3, 4);
    Point p3 = p1 + p2; // 使用重载的 + 运算符
    p3.display(); // 输出: (4, 6)
    return 0;
}
```

在这个示例中，我们定义了一个 `Point` 类，并重载了 `+` 运算符。`operator+` 函数返回一个新的 `Point` 对象，其 x 和 y 坐标分别是对应坐标的和。

### 示例：重载插入运算符 (`<<`)

为了方便打印自定义类型的对象，我们可以重载插入运算符 `<<`：

``` cpp
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 重载插入运算符
    friend ostream& operator<<(ostream &os, const Point &p) {
        os << "(" << p.x << ", " << p.y << ")";
        return os;
    }
};

int main() {
    Point p1(1, 2), p2(3, 4);
    cout << p1 << endl; // 输出: (1, 2)
    cout << p2 << endl; // 输出: (3, 4)
    return 0;
}
```

在这个示例中，我们重载了 `<<` 运算符，使得 `Point` 对象可以直接使用 `cout` 输出。注意，我们将 `operator<<` 函数声明为友元函数，以便它可以访问 `Point` 类的私有成员。

### 示例：重载赋值运算符 (`=`)

重载赋值运算符通常用于自定义类的深拷贝：

``` cpp
#include <iostream>
using namespace std;

class Point {
private:
    int x, y;
public:
    Point(int x = 0, int y = 0) : x(x), y(y) {}

    // 重载赋值运算符
    Point& operator=(const Point &p) {
        if (this != &p) { // 防止自赋值
            x = p.x;
            y = p.y;
        }
        return *this;
    }

    void display() const {
        cout << "(" << x << ", " << y << ")" << endl;
    }
};

int main() {
    Point p1(1, 2), p2;
    p2 = p1; // 使用重载的 = 运算符
    p2.display(); // 输出: (1, 2)
    return 0;
}
```

在这个示例中，我们重载了赋值运算符 `=`，并在操作前检查自赋值情况。

### 总结

运算符重载允许你定义或修改运算符对自定义类型的行为，从而使自定义类型可以像内置类型一样使用运算符。运算符重载常用于增强代码的可读性和可维护性，但需谨慎使用，以避免混淆和误用。