## 新的数据类型

## 类（类型）的定义

私有成员 (private)：只能由类的成员函数调用
公有成员 (public)：外部函数可以调用，类对外的接口
私有成员被封装在一个类中，类的用户是看不见的


## 常量数据成员

## 静态数据成员与静态成员函数


## 对象的使用

对象赋值语句
同类的对象之间可以互相赋值。例如，假设有两个有理数对象 `r1` 和 `r2`，如果它们属于同一个类，则可以执行以下赋值操作：
``` cpp
r1 = r2;
```

当一个对象赋值给另一个对象时，所有的数据成员都会**逐位拷贝**。上述赋值操作相当于逐个成员变量进行赋值。例如，有理数对象 `r1` 和 `r2` 有成员变量 `num` 和 `den`，那么赋值操作相当于：

``` cpp
r1.num = r2.num;
r1.den = r2.den;
```

逐位拷贝：
``` cpp
class A {
public:
    int a;
    int b[5];
};

A x, y;

// 设置对象 x 的成员变量
x.a = 10;
for (int i = 0; i < 5; i++) {
    x.b[i] = i;
}

// 将对象 x 赋值给对象 y
y = x;
```


## 对象的构造与析构

``` cpp
class DoubleArray {
private:
    int low;
    int high;
    double* storage;
	
public:
    // 构造函数
    DoubleArray(int lh, int rh) : low(lh), high(rh) {
        storage = new double[high - low + 1];
    }
	// 设置数组元素的值
    bool set(int index, double value);
    // 取数据元素的值，把结果存储在value中
    bool fetch(int index, double &value);
    // 析构函数
    ~DoubleArray() {
        delete[] storage; // 释放动态分配的内存
    }
};
```

### 对象的构造

一旦有自定义构造函数，系统缺省构造函数消失

动态变量初始化在类型后面用圆括号指出实参表，例如：
``` cpp
p = new DoubleArray(20, 30);
```

初始化列表方法：
``` cpp
DoubleArray::DoubleArray(int lh, int rh) : low(lh), high(rh)
{
    storage = new double[high - low + 1];
}
```

构造函数可以重载，导致对象可以有多种方式构造

### 对象的析构

并非每个类都必须要有析构函数，如 Rational 类就不需要，取决于是否有善后工作。

一般在构造函数中有动态申请内存的，必须有析构函数， 由它释放内存。

### 拷贝构造函数

- 创建对象时，可用一个同类的对象对其初始化。
- 需用一个特殊的构造函数：**拷贝（复制）构造函数**。
- 拷贝构造函数以**同类对象引用作为参数**：
``` cpp
ClassName (const ClassName &)；
```

缺省的拷贝构造函数：如果用户未定义拷贝构造函数，系统会定义一个缺省的拷贝构造函数。该函数将已存在的对象原式原样地复制给新成员

```cpp
class point
{
    int x, y;
public:
    point(int a, int b) { x = a; y = b; }
    point(const point &p) { x = 2 * p.x; y = 2 * p.y; }
}
```


## 常量对象与 const 成员函数


## 常量数据成员


## 静态数据成员与静态成员函数


## 友元

- 私有成员只能让它的成员函数来访问。
- 友元函数是一扇通往私有成员的**后门**。
- 友元可以是：
  - 外部函数（友元函数）
  - 另一个类的成员函数（友元成员）
  - 整个类（友元类）


- 友元关系是**授予**，**非索取**。
  - 如果函数 `f` 要成为类 `A` 的友元，类 `A` 必须显式声明函数 `f` 是它的友元，而不是函数 `f` 自称是类 `A` 的友元。

- 友元关系**不是对称关系**。
  - 如果类 `A` 声明了类 `B` 是它的友元，并不意味着类 `A` 也是类 `B` 的友元。

- 友元关系**不是传递关系**。
  - 如果类 `A` 是类 `B` 的友元，类 `B` 是类 `C` 的友元，并不意味着类 `A` 是类 `C` 的友元。

``` cpp
// 定义在类内
#include <iostream>
#include <string.h>
using namespace std;

class girl {
  char name[10];
  int age;

public:
  girl(char *n, int d) {
    strcpy(name, n);
    age = d;
  }
  // 定义在类内
  friend void disp(girl &x) { cout << x.name << " " << x.age << endl; }
};

int main() {
  girl e("abc", 15);
  disp(e);
  return 0;
}

```

``` cpp
// 定义在类外
#include <iostream>
#include <string.h>
using namespace std;

class girl {
  char name[10];
  int age;

public:
  girl(char *n, int d) {
    strcpy(name, n);
    age = d;
  }
  // 声明在类内
  friend void disp(girl &x);
};

// 定义在类外
void disp(girl &x) { 
  cout << x.name << " " << x.age << endl; 
}

int main() {
  girl e("abc", 15);
  disp(e);
  return 0;
}

```


 