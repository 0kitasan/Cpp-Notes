## 组合

定义一个复数类，而复数的虚部和实部都用有理数表示，实现复数的加法和输出

方案：利用已有的有理数类，复数类的数据成员是两个有理数类对象

```cpp
class Rational {
  int num;
  int den;
  void ReductFraction();

public:
  Rational(int a = 0, int b = 1);
  void add(const Rational &r1, const Rational &r2);
  // r3.add(r1, r2)
  void multi(const Rational &r1, const Rational &r2);
  // r3.multi(r1, r2)
  void display();
};

class Complex {
private:
  Rational Re;
  Rational Im;

public:
  Complex(int r1 = 0, int r2 = 1, int i1 = 0, int i2 = 1)
      : Re(r1, r2), Im(i1, i2) {}
  Complex(Rational r1, Rational r2) : Re(r1), Im(r2) {}
  void add(const Complex &c1, const Complex &c2) {
    Re.add(c1.Re, c2.Re);
    Im.add(c1.Im, c2.Im);
  }
  void display() {
    Re.display();
    cout << '+';
    Im.display();
    cout << 'i';
  }
};

```

## 继承

### 派生类的定义

protected 访问特性：protected 成员是一类特殊的私有成员，
它不可以被全局函数或其他类的成员函数访问，但能被派
生类的成员函数和友元函数访问

``` cpp
class 派生类名 : 派生方法 基类名
{
    // 派生类新增的数据成员和成员函数
};
```


|           | 基类成员在派生类中的访问特性                                                            |
| :-------: | ------------------------------------------------------------------------- |
|  public   | 在派生类中为 public，<br />可以由任何非 static 成员函数、友元函数和非成员函数访问                       |
| protected | 在派生类中为 protected，<br />可以直接由任何非 static 成员函数、友元函数访问                        |
|  private  | 在派生类中隐藏，<br />可以通过基类的 public 或 protected 成员函数、<br />或非 static 成员函数和友元函数访问 |


### 派生实例

```cpp
class base {
  int x; // 默认为private

public:
  void setx(int k);
};

class derived1 : public base {
  int y; // derived1 有两个成员变量x,y

public:
  void sety(int k);
  // derived1 有两个成员函数 setx,sety
};

```

### 派生类对象的构造

派生类对象的构造
* 派生类的构造函数体负责派生类新增成员的构造
* 基类部分由基类构造函数完成
* 派生类构造函数调用基类的构造函数
* 派生类构造函数的格式：`派生类构造函数名（参数表）：基类构造函数名（参数表）{...} `




派生类引用基类的同名函数
### 虚函数



``` cpp
class Shape {
public:
    virtual void printShapeName() { cout << "Shape" << endl; }
};

class Point : public Shape {
public:
    virtual void printShapeName() { cout << "Point" << endl; }
};

class Circle : public Point {
public:
    virtual void printShapeName() { cout << "Circle" << endl; }
};

class Cylinder : public Circle {
public:
    virtual void printShapeName() { cout << "Cylinder" << endl; }
};

int main(){
	Shape * shape_list[3];
	shape_list[0] = new Pi

}
```



## 抽象类


